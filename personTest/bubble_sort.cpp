/*
 * @Descripttion: MyCode
 * @Author: CGPan
 * @Date: 2022-10-27 12:31:17
 * @LastEditors: CGPan
 * @LastEditTime: 2022-12-06 17:26:37
 */
#include <iostream>
/*对于排序数据13,16,17,18,16,14,15,12,25,21,26
  使用冒泡排序按从小到大排序：则是在每 i 轮for_loop中,
  确定好每个倒数第 i 最大值的位置:
  第一轮for_loop中，i == 0 时：选取最大的数放在最右边
  所以则是当arr[j] > arr[j+1]时,交换两个的位置，一直交换到最后那个数，
  则确定好了第0(数组中第一个数的位置为0)个最大值的位置
  如下： j = 0： 13 < 16,不交换，j++;
        j = 1:  16 < 17,不交换，j++;
        j = 2:  17 < 18,不交换，j++;
        j = 3:  18 > 16,交换位置变成:13,16,17,16,18,14,15,12,25,21,26，j++;
        j = 4:  18 > 14,交换位置变成:13,16,17,16,14,18,15,12,25,21,26，j++;
        …………
        j = 10: 25 < 26,不交换，结果为：13 16 17 16 14 15 12 18 21 25 26
        即在该轮for_loop中，我们确定了最大的那个数26在最后的那个位置
  第二轮，i == 1时,也按照同样的道理，但是我们只比到 j = 9时,即 
  for (int j = 0; j < N - i - 1; ++j)中的 j < N - i - 1;
  因为第一轮中，我们已经把最大的那个放在了最后的位置，它的位置就已经固定了，
  我们只需要确定第二个最大值的位置在第一个最大值前面就行
  得结果：13 16 16 14 15 12 17 18 21 25 26 
  ……
  就这样，直到 i == N - 1时，那么此时 (N - i -1)即为 0,即排序完毕
  结果为：12 13 14 15 16 16 17 18 21 25 26

*/
using namespace std;
void bubble_sort(int arr[], int N) {

    for (int i = 0; i < N - 1; ++i) {

        for (int j = 0; j < N - i - 1; ++j) {

            if (arr[j] > arr[j+1]) swap(arr[j],arr[j+1]);
        }
         cout << "第" << i+1 << "趟：" ;
        for (int k = 0; k < N; ++k) {
           cout << arr[k] << " ";
        }
        cout << "\n";
    }

}

int main()
{
    int arr[] = {3,1,4,1,5,9,2,6};
    int N = 8;
    bubble_sort(arr,N);
    // for (int i = 0; i < N; ++i) {
    //     cout << arr[i] << " ";
    // }
    cout << endl;
    return 0;

}
